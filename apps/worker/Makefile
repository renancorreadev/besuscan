# Worker Makefile
# Comandos para gerenciar o worker e monitorar RabbitMQ

.PHONY: help build-dev build-prod dev prod run clean check-consumers kill-consumers logs docker-login

# Vari√°veis
BINARY_NAME=worker
DOCKER_COMPOSE=docker-compose
RABBITMQ_HOST=147.93.11.54

# Docker Hub config
DOCKER_USER=besuscan
DEV_REPO=$(DOCKER_USER)/worker-dev
PROD_REPO=$(DOCKER_USER)/worker

# Vers√£o padr√£o para desenvolvimento
DEV_VERSION ?= v0.0.1

# Pega a vers√£o do primeiro argumento ap√≥s o target
VERSION = $(word 2,$(MAKECMDGOALS))
# Ignora argumentos desconhecidos
%:
	@:

# Cores para output
GREEN := \033[0;32m
RED := \033[0;31m
YELLOW := \033[0;33m
BLUE := \033[0;34m
NC := \033[0m

help: ## Mostrar ajuda
	@echo "$(BLUE)üîß Comandos para Docker:$(NC)"
	@echo "  make dev 0.0.1             # Build e push da imagem de desenvolvimento"
	@echo "  make prod 1.0.0            # Build e push da imagem de produ√ß√£o"
	@echo "  make docker-login          # Login no Docker Hub"
	@echo ""
	@echo "$(BLUE)üê≥ Imagens geradas:$(NC)"
	@echo "  Desenvolvimento:"
	@echo "    ‚Ä¢ $(DEV_REPO):latest"
	@echo "    ‚Ä¢ $(DEV_REPO):vX.Y.Z"
	@echo "  Produ√ß√£o:"
	@echo "    ‚Ä¢ $(PROD_REPO):latest"
	@echo "    ‚Ä¢ $(PROD_REPO):vX.Y.Z"
	@echo ""
	@echo "$(BLUE)üöÄ Comandos para execu√ß√£o local:$(NC)"
	@echo "  make run                   # Executar worker localmente"
	@echo "  make test                  # Executar testes"
	@echo "  make lint                  # Executar linter"
	@echo ""
	@echo "$(BLUE)üì¶ Comandos para Docker Compose:$(NC)"
	@echo "  make start                 # Iniciar worker no Docker"
	@echo "  make stop                  # Parar worker no Docker"
	@echo "  make restart               # Reiniciar worker no Docker"
	@echo "  make logs                  # Ver logs do worker"
	@echo "  make status                # Status dos servi√ßos"
	@echo ""
	@echo "$(BLUE)üîç Comandos para monitoramento:$(NC)"
	@echo "  make health                # Verificar sa√∫de do sistema"
	@echo "  make check-consumers       # Verificar consumidores RabbitMQ"
	@echo "  make kill-consumers        # For√ßar fechamento de conex√µes RabbitMQ"
	@echo "  make cleanup-consumers     # Limpar consumidores √≥rf√£os"
	@echo "  make debug                 # Ver informa√ß√µes de debug"
	@echo ""
	@echo "$(BLUE)üßπ Outros comandos:$(NC)"
	@echo "  make clean                 # Limpar arquivos tempor√°rios"
	@echo "  make mod-tidy              # Limpar depend√™ncias Go"

docker-login: ## Login no Docker Hub
	@echo "$(GREEN)üîë Fazendo login no Docker Hub como $(DOCKER_USERNAME)...$(NC)"
	@if [ -z "$(DOCKER_USERNAME)" ] || [ -z "$(DOCKER_PASSWORD)" ]; then \
		echo "$(RED)‚ùå DOCKER_USERNAME e DOCKER_PASSWORD s√£o necess√°rios$(NC)"; \
		exit 1; \
	fi
	@echo "$(DOCKER_PASSWORD)" | docker login -u $(DOCKER_USERNAME) --password-stdin

# Comandos Docker simplificados
dev: ## Build e push imagem de desenvolvimento
	@if [ -z "$(VERSION)" ]; then \
		VERSION=$(DEV_VERSION); \
	else \
		VERSION="v$(VERSION)"; \
	fi; \
	echo "$(GREEN)üê≥ Construindo imagem de desenvolvimento ($$VERSION)...$(NC)"; \
	docker build -t $(DEV_REPO):latest -f Dockerfile.dev .; \
	docker tag $(DEV_REPO):latest $(DEV_REPO):$$VERSION; \
	echo "$(GREEN)üê≥ Pushing imagem de desenvolvimento...$(NC)"; \
	docker push $(DEV_REPO):latest; \
	docker push $(DEV_REPO):$$VERSION; \
	echo "$(GREEN)‚úÖ Imagem de desenvolvimento publicada:$(NC)"; \
	echo "  ‚Ä¢ $(DEV_REPO):latest"; \
	echo "  ‚Ä¢ $(DEV_REPO):$$VERSION"

prod: ## Build e push imagem de produ√ß√£o
	@if [ -z "$(VERSION)" ]; then \
		echo "$(RED)‚ùå Vers√£o n√£o especificada. Use: make prod x.y.z$(NC)"; \
		exit 1; \
	fi
	@echo "$(GREEN)üê≥ Construindo imagem de produ√ß√£o (v$(VERSION))...$(NC)"
	@docker build -t $(PROD_REPO):latest -f Dockerfile .
	@docker tag $(PROD_REPO):latest $(PROD_REPO):v$(VERSION)
	@echo "$(GREEN)üê≥ Pushing imagem de produ√ß√£o...$(NC)"
	@docker push $(PROD_REPO):latest
	@docker push $(PROD_REPO):v$(VERSION)
	@echo "$(GREEN)‚úÖ Imagem de produ√ß√£o publicada:$(NC)"
	@echo "  ‚Ä¢ $(PROD_REPO):latest"
	@echo "  ‚Ä¢ $(PROD_REPO):v$(VERSION)"

run: ## Executar o worker localmente
	@echo "üöÄ Executando worker..."
	go run ./cmd/main.go

clean: ## Limpar arquivos tempor√°rios
	@echo "üßπ Limpando arquivos tempor√°rios..."
	rm -rf tmp/
	rm -rf bin/
	rm -f build-errors.log
	rm -f log.txt
	@echo "‚úÖ Limpeza conclu√≠da"

check-consumers: ## Verificar consumidores RabbitMQ ativos
	@echo "üîç Verificando consumidores RabbitMQ..."
	@if [ -f scripts/check-consumers.sh ]; then \
		./scripts/check-consumers.sh; \
	else \
		echo "‚ùå Script check-consumers.sh n√£o encontrado"; \
	fi

kill-consumers: ## For√ßar fechamento de todas as conex√µes RabbitMQ
	@echo "‚ö†Ô∏è For√ßando fechamento de conex√µes RabbitMQ..."
	@echo "Isso ir√° desconectar TODOS os consumidores!"
	@read -p "Tem certeza? (y/N): " confirm && [ "$$confirm" = "y" ] || exit 1
	@curl -s -u guest:guest -X DELETE "http://$(RABBITMQ_HOST):15673/api/connections" || echo "‚ùå Erro ao fechar conex√µes"
	@echo "‚úÖ Comando enviado para fechar conex√µes"

cleanup-consumers: ## Limpar consumidores √≥rf√£os (desenvolvimento)
	@echo "üßπ Limpando consumidores √≥rf√£os..."
	@if [ -f scripts/cleanup-consumers.sh ]; then \
		./scripts/cleanup-consumers.sh; \
	else \
		echo "‚ùå Script cleanup-consumers.sh n√£o encontrado"; \
	fi

logs: ## Mostrar logs do container Docker
	@echo "üìã Logs do worker..."
	$(DOCKER_COMPOSE) logs -f worker

restart: ## Reiniciar o worker no Docker
	@echo "üîÑ Reiniciando worker..."
	$(DOCKER_COMPOSE) restart worker
	@echo "‚úÖ Worker reiniciado"

stop: ## Parar o worker no Docker
	@echo "üõë Parando worker..."
	$(DOCKER_COMPOSE) stop worker
	@echo "‚úÖ Worker parado"

start: ## Iniciar o worker no Docker
	@echo "üöÄ Iniciando worker..."
	$(DOCKER_COMPOSE) start worker
	@echo "‚úÖ Worker iniciado"

status: ## Verificar status dos servi√ßos
	@echo "üìä Status dos servi√ßos:"
	$(DOCKER_COMPOSE) ps

health: ## Verificar sa√∫de do sistema (RabbitMQ + PostgreSQL)
	@echo "üè• Verificando sa√∫de do sistema..."
	@echo "RabbitMQ:"
	@curl -s -u guest:guest "http://$(RABBITMQ_HOST):15673/api/overview" | jq -r '.rabbitmq_version // "‚ùå N√£o conectado"' || echo "‚ùå RabbitMQ n√£o acess√≠vel"
	@echo "PostgreSQL:"
	@$(DOCKER_COMPOSE) exec -T postgres pg_isready || echo "‚ùå PostgreSQL n√£o acess√≠vel"

debug: ## Informa√ß√µes de debug
	@echo "üêõ Informa√ß√µes de debug:"
	@echo "Vari√°veis de ambiente:"
	@env | grep -E "(RABBITMQ|DATABASE|ETH)" || echo "Nenhuma vari√°vel encontrada"
	@echo ""
	@echo "Processos Go ativos:"
	@ps aux | grep -E "(air|worker|main)" | grep -v grep || echo "Nenhum processo encontrado"

# Comandos para desenvolvimento
test: ## Executar testes
	@echo "üß™ Executando testes..."
	go test ./...

lint: ## Executar linter
	@echo "üîç Executando linter..."
	golangci-lint run

mod-tidy: ## Limpar depend√™ncias Go
	@echo "üì¶ Limpando depend√™ncias..."
	go mod tidy 