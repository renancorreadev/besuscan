{
  "address": "0x7eF84473a4E772fB6aDfA1B0C6728A3dbf268Dd7",
  "creation_block_number": 32627,
  "creator_address": "0xFE3B557E8Fb62b89F4916B721be55cEb828dBd73",
  "deployment": {
    "name": "VFinance Registry Implementation",
    "description": "Implementação do contrato VFinance Registry para financiamento de veículos",
    "contract_type": "UUPS Implementation",
    "source_code": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.25 ^0.8.20;\n\n// lib/openzeppelin-contracts/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n\n// lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n// lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) \u0026 ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 \u0026\u0026 isTopLevelCall;\n        bool construction = initialized == 1 \u0026\u0026 address(this).code.length == 0;\n\n        if (!initialSetup \u0026\u0026 !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized \u003e= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length \u003e 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n\n// lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n\n// lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n\n// lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) \u0026 ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value \u003e 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length \u003e 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length \u003e 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value \u003e 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n\n// lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n\n// lib/openzeppelin-contracts-upgradeable/contracts/token/ERC721/ERC721Upgradeable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC721\n    struct ERC721Storage {\n        // Token name\n        string _name;\n\n        // Token symbol\n        string _symbol;\n\n        mapping(uint256 tokenId =\u003e address) _owners;\n\n        mapping(address owner =\u003e uint256) _balances;\n\n        mapping(uint256 tokenId =\u003e address) _tokenApprovals;\n\n        mapping(address owner =\u003e mapping(address operator =\u003e bool)) _operatorApprovals;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC721\")) - 1)) \u0026 ~bytes32(uint256(0xff))\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length \u003e 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) \u0026\u0026\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n\n        $._owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) \u0026\u0026 owner != auth \u0026\u0026 !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        $._tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length \u003e 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n\n// src/VFinanceRegistry.sol\n\n/**\n * @title VFinanceRegistry\n * @dev Optimized vehicle financing contract registry using NFT infrastructure\n * @notice Uses NFT tokenURI system to connect with metadata server, not as traditional NFTs\n * @author VFinance Team\n * @custom:security-contact security@vfinance.com.br\n * @custom:version 2.0.0\n * @custom:besu-optimized Optimized for Hyperledger Besu\n */\ncontract VFinanceRegistry is\n    Initializable,\n    ERC721Upgradeable,\n    OwnableUpgradeable,\n    UUPSUpgradeable\n{\n    // =============================================================\n    //                          CONSTANTS\n    // =============================================================\n\n    /// @dev Contract version for upgrade control\n    string public constant VERSION = \"2.0.0\";\n\n    /// @dev Maximum contracts that can be registered (optimized for Besu)\n    uint256 public constant MAX_SUPPLY = 10000000; // 10M contracts\n\n    /// @dev Event prefix for traceability\n    bytes32 private constant EVENT_PREFIX = keccak256(\"VFINANCE_REGISTRY_V2\");\n\n    // =============================================================\n    //                           STRUCTS\n    // =============================================================\n\n    /**\n     * @dev Main contract data (optimized for storage)\n     */\n    struct ContractRecord {\n        bytes32 registryId; // Unique contract ID converted to bytes32 (gas savings)\n        bytes32 contractNumber; // Contract number in bytes32\n        uint32 contractDate; // Contract date timestamp (uint32 sufficient until 2106)\n        bytes32 metadataHash; // SHA256 hash of metadata\n        uint32 timestamp; // Registration timestamp (uint32)\n        address registeredBy; // Address that registered\n        bool active; // Active/inactive status\n    }\n\n    /**\n     * @dev Critical vehicle data for traceability (packed for efficiency)\n     */\n    struct VehicleCore {\n        bytes32 chassis; // Vehicle chassis in bytes32 (17 chars fit)\n        bytes32 licensePlate; // License plate in bytes32 (7-8 chars)\n        uint128 totalValue; // Total value in wei (uint128 supports up to ~340 trillion)\n        uint64 brandId; // Brand ID (internal enum)\n        uint64 modelId; // Model ID (internal enum)\n    }\n\n    // =============================================================\n    //                        STATE VARIABLES\n    // =============================================================\n\n    /// @dev Mapping from tokenId to contract data (packed struct)\n    mapping(uint256 =\u003e ContractRecord) public contracts;\n\n    /// @dev Mapping from registryId hash to tokenId (bytes32 for efficiency)\n    mapping(bytes32 =\u003e uint256) public registryIdHashToTokenId;\n\n    /// @dev Mapping from metadata hash to tokenId\n    mapping(bytes32 =\u003e uint256) public metadataHashToTokenId;\n\n    /// @dev Mapping from tokenId to vehicle data (packed struct)\n    mapping(uint256 =\u003e VehicleCore) public vehicleCores;\n\n    /// @dev Mapping from chassis hash to tokenId (anti-duplication)\n    mapping(bytes32 =\u003e uint256) public chassisHashToTokenId;\n\n    /// @dev Current token counter (optimized)\n    uint256 private _currentIndex;\n\n    /// @dev Authorized API server address\n    address public apiServerAddress;\n\n    /// @dev Base URL for metadata (compact string)\n    string public metadataBaseUrl;\n\n    /// @dev Mapping for brands (ID -\u003e name) - storage savings\n    mapping(uint64 =\u003e string) public brands;\n    uint64 private _brandIdCounter;\n\n    /// @dev Mapping for models (ID -\u003e name) - storage savings\n    mapping(uint64 =\u003e string) public models;\n    uint64 private _modelIdCounter;\n\n    // =============================================================\n    //                            EVENTS\n    // =============================================================\n\n    /**\n     * @dev Main registration event (optimized for Besu indexing)\n     */\n    event ContractRegistered(\n        uint256 indexed tokenId,\n        bytes32 indexed registryIdHash,\n        bytes32 indexed chassisHash,\n        bytes32 metadataHash,\n        uint32 timestamp\n    );\n\n    /**\n     * @dev Vehicle traceability event\n     */\n    event VehicleTracked(\n        uint256 indexed tokenId,\n        bytes32 indexed chassis,\n        bytes32 indexed licensePlate,\n        uint128 totalValue,\n        uint64 brandId,\n        uint64 modelId\n    );\n\n    /**\n     * @dev Metadata update event\n     */\n    event MetadataUpdated(\n        uint256 indexed tokenId,\n        bytes32 indexed oldHash,\n        bytes32 indexed newHash,\n        uint32 timestamp\n    );\n\n    /**\n     * @dev Status change event\n     */\n    event StatusChanged(\n        uint256 indexed tokenId,\n        bool indexed active,\n        uint32 timestamp\n    );\n\n    /**\n     * @dev System configuration event\n     */\n    event SystemConfigured(address indexed apiServer, string metadataUrl);\n\n    /**\n     * @dev Brand registered event\n     */\n    event BrandRegistered(uint64 indexed brandId, string brandName);\n\n    /**\n     * @dev Model registered event\n     */\n    event ModelRegistered(uint64 indexed modelId, string modelName);\n\n    // =============================================================\n    //                            ERRORS\n    // =============================================================\n\n    error ContractAlreadyExists();\n    error ContractNotFound();\n    error InvalidInput();\n    error UnauthorizedAccess();\n    error DuplicateHash();\n    error MaxSupplyExceeded();\n    error TokenNotFound();\n\n    // =============================================================\n    //                           MODIFIERS\n    // =============================================================\n\n    /**\n     * @dev Only API server or owner\n     */\n    modifier onlyAuthorized() {\n        if (msg.sender != apiServerAddress \u0026\u0026 msg.sender != owner()) {\n            revert UnauthorizedAccess();\n        }\n        _;\n    }\n\n    /**\n     * @dev Check if token exists\n     */\n    modifier validToken(uint256 tokenId) {\n        if (tokenId == 0 || tokenId \u003e= _currentIndex) {\n            revert TokenNotFound();\n        }\n        _;\n    }\n\n    // =============================================================\n    //                        INITIALIZATION\n    // =============================================================\n\n    /**\n     * @dev Initialize the contract (optimized for Besu)\n     */\n    function initialize(\n        string memory name,\n        string memory symbol,\n        string memory _metadataBaseUrl,\n        address _apiServerAddress\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __Ownable_init(msg.sender);\n        __UUPSUpgradeable_init();\n\n        metadataBaseUrl = _metadataBaseUrl;\n        apiServerAddress = _apiServerAddress;\n        _currentIndex = 1; // Start from tokenId 1\n\n        // Register common brands (future gas savings)\n        _registerBrand(\"TOYOTA\");\n        _registerBrand(\"HONDA\");\n        _registerBrand(\"VOLKSWAGEN\");\n        _registerBrand(\"FIAT\");\n        _registerBrand(\"CHEVROLET\");\n        _registerBrand(\"FORD\");\n        _registerBrand(\"NISSAN\");\n        _registerBrand(\"HYUNDAI\");\n        _registerBrand(\"RENAULT\");\n        _registerBrand(\"PEUGEOT\");\n\n        emit SystemConfigured(_apiServerAddress, _metadataBaseUrl);\n    }\n\n    // =============================================================\n    //                      CORE FUNCTIONALITY\n    // =============================================================\n\n    /**\n     * @dev Register optimized contract (main function)\n     * @param registryId Unique contract ID (string converted to bytes32)\n     * @param contractNumber Contract number\n     * @param contractDate Contract date timestamp\n     * @param chassis Vehicle chassis\n     * @param licensePlate Vehicle license plate\n     * @param totalValue Contract value in wei\n     * @param brandName Brand name (will be converted to ID)\n     * @param modelName Model name (will be converted to ID)\n     * @return tokenId Created registry token ID (for internal reference only)\n     * @return metadataHash Generated metadata hash (connects to metadata server)\n     */\n    function registerContract(\n        string calldata registryId,\n        string calldata contractNumber,\n        uint32 contractDate,\n        string calldata chassis,\n        string calldata licensePlate,\n        uint128 totalValue,\n        string calldata brandName,\n        string calldata modelName\n    ) external onlyAuthorized returns (uint256 tokenId, bytes32 metadataHash) {\n        // Basic validations\n        if (bytes(registryId).length == 0 || bytes(chassis).length == 0) {\n            revert InvalidInput();\n        }\n        if (_currentIndex \u003e MAX_SUPPLY) revert MaxSupplyExceeded();\n\n        // Convert strings to bytes32 (gas savings)\n        bytes32 registryIdHash = keccak256(bytes(registryId));\n        bytes32 contractNumberBytes = _stringToBytes32(contractNumber);\n        bytes32 chassisBytes = _stringToBytes32(chassis);\n        bytes32 licensePlateBytes = _stringToBytes32(licensePlate);\n\n        // Check for duplicates\n        if (registryIdHashToTokenId[registryIdHash] != 0)\n            revert ContractAlreadyExists();\n        if (chassisHashToTokenId[keccak256(bytes(chassis))] != 0)\n            revert ContractAlreadyExists();\n\n        // Generate tokenId and metadata hash\n        tokenId = _currentIndex++;\n        metadataHash = keccak256(\n            abi.encodePacked(\n                registryIdHash,\n                contractNumberBytes,\n                contractDate,\n                chassisBytes,\n                tokenId,\n                block.timestamp\n            )\n        );\n\n        // Check unique hash\n        if (metadataHashToTokenId[metadataHash] != 0) revert DuplicateHash();\n\n        // Get brand and model IDs (register if doesn't exist)\n        uint64 brandId = _getOrCreateBrandId(brandName);\n        uint64 modelId = _getOrCreateModelId(modelName);\n\n        // Mint registry token (non-transferable, used only for tokenURI system)\n        _mint(address(this), tokenId);\n\n        // Store data (packed structs for savings)\n        contracts[tokenId] = ContractRecord({\n            registryId: registryIdHash,\n            contractNumber: contractNumberBytes,\n            contractDate: contractDate,\n            metadataHash: metadataHash,\n            timestamp: uint32(block.timestamp),\n            registeredBy: msg.sender,\n            active: true\n        });\n\n        vehicleCores[tokenId] = VehicleCore({\n            chassis: chassisBytes,\n            licensePlate: licensePlateBytes,\n            totalValue: totalValue,\n            brandId: brandId,\n            modelId: modelId\n        });\n\n        // Update mappings\n        registryIdHashToTokenId[registryIdHash] = tokenId;\n        metadataHashToTokenId[metadataHash] = tokenId;\n        chassisHashToTokenId[keccak256(bytes(chassis))] = tokenId;\n\n        // Emit optimized events\n        emit ContractRegistered(\n            tokenId,\n            registryIdHash,\n            keccak256(bytes(chassis)),\n            metadataHash,\n            uint32(block.timestamp)\n        );\n\n        emit VehicleTracked(\n            tokenId,\n            chassisBytes,\n            licensePlateBytes,\n            totalValue,\n            brandId,\n            modelId\n        );\n\n        return (tokenId, metadataHash);\n    }\n\n    /**\n     * @dev Update metadata hash (optimized)\n     */\n    function updateMetadataHash(\n        uint256 tokenId,\n        bytes32 newMetadataHash\n    ) external onlyAuthorized validToken(tokenId) {\n        if (newMetadataHash == bytes32(0)) revert InvalidInput();\n        if (metadataHashToTokenId[newMetadataHash] != 0) revert DuplicateHash();\n\n        bytes32 oldHash = contracts[tokenId].metadataHash;\n\n        // Update mappings\n        delete metadataHashToTokenId[oldHash];\n        contracts[tokenId].metadataHash = newMetadataHash;\n        metadataHashToTokenId[newMetadataHash] = tokenId;\n\n        emit MetadataUpdated(\n            tokenId,\n            oldHash,\n            newMetadataHash,\n            uint32(block.timestamp)\n        );\n    }\n\n    /**\n     * @dev Update contract status\n     */\n    function updateStatus(\n        uint256 tokenId,\n        bool active\n    ) external onlyAuthorized validToken(tokenId) {\n        contracts[tokenId].active = active;\n        emit StatusChanged(tokenId, active, uint32(block.timestamp));\n    }\n\n    // =============================================================\n    //                        VIEW FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Get complete contract data by tokenId\n     */\n    function getContract(\n        uint256 tokenId\n    )\n        external\n        view\n        validToken(tokenId)\n        returns (ContractRecord memory, VehicleCore memory)\n    {\n        return (contracts[tokenId], vehicleCores[tokenId]);\n    }\n\n    /**\n     * @dev Get contract by registryId string\n     */\n    function getContractByRegistryId(\n        string calldata registryId\n    ) external view returns (ContractRecord memory, VehicleCore memory) {\n        bytes32 registryIdHash = keccak256(bytes(registryId));\n        uint256 tokenId = registryIdHashToTokenId[registryIdHash];\n        if (tokenId == 0) revert ContractNotFound();\n        return (contracts[tokenId], vehicleCores[tokenId]);\n    }\n\n    /**\n     * @dev Get contract by metadata hash\n     */\n    function getContractByHash(\n        bytes32 metadataHash\n    ) external view returns (ContractRecord memory, VehicleCore memory) {\n        uint256 tokenId = metadataHashToTokenId[metadataHash];\n        if (tokenId == 0) revert ContractNotFound();\n        return (contracts[tokenId], vehicleCores[tokenId]);\n    }\n\n    /**\n     * @dev Get contract by chassis\n     */\n    function getContractByChassis(\n        string calldata chassis\n    ) external view returns (ContractRecord memory, VehicleCore memory) {\n        bytes32 chassisHash = keccak256(bytes(chassis));\n        uint256 tokenId = chassisHashToTokenId[chassisHash];\n        if (tokenId == 0) revert ContractNotFound();\n        return (contracts[tokenId], vehicleCores[tokenId]);\n    }\n\n    /**\n     * @dev Get active contracts with pagination (optimized)\n     */\n    function getActiveContracts(\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory tokenIds) {\n        if (limit == 0 || limit \u003e 100) revert InvalidInput();\n\n        uint256 totalTokens = _currentIndex - 1;\n        uint256 activeCount = 0;\n\n        // Count active contracts\n        for (uint256 i = 1; i \u003c= totalTokens; i++) {\n            if (contracts[i].active) {\n                activeCount++;\n            }\n        }\n\n        if (offset \u003e= activeCount) {\n            return new uint256[](0);\n        }\n\n        uint256 resultSize = activeCount - offset;\n        if (resultSize \u003e limit) {\n            resultSize = limit;\n        }\n\n        tokenIds = new uint256[](resultSize);\n        uint256 currentIndex = 0;\n        uint256 resultIndex = 0;\n\n        for (uint256 i = 1; i \u003c= totalTokens \u0026\u0026 resultIndex \u003c resultSize; i++) {\n            if (contracts[i].active) {\n                if (currentIndex \u003e= offset) {\n                    tokenIds[resultIndex] = i;\n                    resultIndex++;\n                }\n                currentIndex++;\n            }\n        }\n\n        return tokenIds;\n    }\n\n    /**\n     * @dev Get total supply\n     */\n    function totalSupply() public view returns (uint256) {\n        return _currentIndex - 1;\n    }\n\n    /**\n     * @dev Check if contract exists by registryId\n     */\n    function doesContractExist(\n        string calldata registryId\n    ) external view returns (bool) {\n        bytes32 registryIdHash = keccak256(bytes(registryId));\n        return registryIdHashToTokenId[registryIdHash] != 0;\n    }\n\n    /**\n     * @dev Check if hash exists\n     */\n    function doesHashExist(bytes32 metadataHash) external view returns (bool) {\n        return metadataHashToTokenId[metadataHash] != 0;\n    }\n\n    /**\n     * @dev Get brand name by ID\n     */\n    function getBrandName(\n        uint64 brandId\n    ) external view returns (string memory) {\n        return brands[brandId];\n    }\n\n    /**\n     * @dev Get model name by ID\n     */\n    function getModelName(\n        uint64 modelId\n    ) external view returns (string memory) {\n        return models[modelId];\n    }\n\n    // =============================================================\n    //                    REGISTRY TOKEN FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Return token URI (metadata server endpoint)\n     * @notice This connects to the metadata server, not for NFT marketplace use\n     */\n    function tokenURI(\n        uint256 tokenId\n    ) public view override validToken(tokenId) returns (string memory) {\n        bytes32 metadataHash = contracts[tokenId].metadataHash;\n        return\n            string(\n                abi.encodePacked(\n                    metadataBaseUrl,\n                    \"/api/metadata/0x\",\n                    _toHexString(metadataHash)\n                )\n            );\n    }\n\n    /**\n     * @dev Override update function to make tokens non-transferable\n     * @notice These are registry entries, not tradeable NFTs\n     */\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal virtual override returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Allow minting (from == address(0)) but block all transfers\n        if (from != address(0) \u0026\u0026 to != address(0)) {\n            revert(\"Registry tokens are non-transferable\");\n        }\n\n        return super._update(to, tokenId, auth);\n    }\n\n    /**\n     * @dev Override approve functions since tokens are non-transferable\n     */\n    function approve(address, uint256) public pure override {\n        revert(\"Registry tokens are non-transferable\");\n    }\n\n    function setApprovalForAll(address, bool) public pure override {\n        revert(\"Registry tokens are non-transferable\");\n    }\n\n    /**\n     * @dev Get metadata URL directly by hash (more efficient than tokenURI)\n     * @notice Primary method for accessing metadata server\n     */\n    function getMetadataUrl(\n        bytes32 metadataHash\n    ) external view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    metadataBaseUrl,\n                    \"/api/metadata/0x\",\n                    _toHexString(metadataHash)\n                )\n            );\n    }\n\n    /**\n     * @dev Get metadata URL by registry ID\n     */\n    function getMetadataUrlByRegistryId(\n        string calldata registryId\n    ) external view returns (string memory) {\n        bytes32 registryIdHash = keccak256(bytes(registryId));\n        uint256 tokenId = registryIdHashToTokenId[registryIdHash];\n        if (tokenId == 0) revert ContractNotFound();\n\n        bytes32 metadataHash = contracts[tokenId].metadataHash;\n        return\n            string(\n                abi.encodePacked(\n                    metadataBaseUrl,\n                    \"/api/metadata/0x\",\n                    _toHexString(metadataHash)\n                )\n            );\n    }\n\n    // =============================================================\n    //                      ADMIN FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Update server configuration\n     */\n    function updateServerConfig(\n        string memory newMetadataBaseUrl,\n        address newApiServerAddress\n    ) external onlyOwner {\n        metadataBaseUrl = newMetadataBaseUrl;\n        apiServerAddress = newApiServerAddress;\n\n        emit SystemConfigured(newApiServerAddress, newMetadataBaseUrl);\n    }\n\n    /**\n     * @dev Register new brand manually\n     */\n    function registerBrand(\n        string calldata brandName\n    ) external onlyOwner returns (uint64 brandId) {\n        return _registerBrand(brandName);\n    }\n\n    /**\n     * @dev Register new model manually\n     */\n    function registerModel(\n        string calldata modelName\n    ) external onlyOwner returns (uint64 modelId) {\n        return _registerModel(modelName);\n    }\n\n    // =============================================================\n    //                      INTERNAL FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Convert string to bytes32 (up to 32 chars)\n     */\n    function _stringToBytes32(\n        string memory source\n    ) internal pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n\n    /**\n     * @dev Convert bytes32 to hex string\n     */\n    function _toHexString(bytes32 hash) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(64);\n        for (uint256 i = 0; i \u003c 32; i++) {\n            buffer[i * 2] = _toHexChar(uint8(hash[i]) / 16);\n            buffer[i * 2 + 1] = _toHexChar(uint8(hash[i]) % 16);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Convert digit to hex char\n     */\n    function _toHexChar(uint8 digit) internal pure returns (bytes1) {\n        return\n            bytes1(\n                digit \u003c 10\n                    ? uint8(bytes1(\"0\")) + digit\n                    : uint8(bytes1(\"a\")) + digit - 10\n            );\n    }\n\n    /**\n     * @dev Register new brand internally\n     */\n    function _registerBrand(\n        string memory brandName\n    ) internal returns (uint64 brandId) {\n        brandId = ++_brandIdCounter;\n        brands[brandId] = brandName;\n        emit BrandRegistered(brandId, brandName);\n        return brandId;\n    }\n\n    /**\n     * @dev Register new model internally\n     */\n    function _registerModel(\n        string memory modelName\n    ) internal returns (uint64 modelId) {\n        modelId = ++_modelIdCounter;\n        models[modelId] = modelName;\n        emit ModelRegistered(modelId, modelName);\n        return modelId;\n    }\n\n    /**\n     * @dev Get or create brand ID\n     */\n    function _getOrCreateBrandId(\n        string calldata brandName\n    ) internal returns (uint64) {\n        // Simple linear search for now (could be optimized with mapping)\n        for (uint64 i = 1; i \u003c= _brandIdCounter; i++) {\n            if (keccak256(bytes(brands[i])) == keccak256(bytes(brandName))) {\n                return i;\n            }\n        }\n        return _registerBrand(brandName);\n    }\n\n    /**\n     * @dev Get or create model ID\n     */\n    function _getOrCreateModelId(\n        string calldata modelName\n    ) internal returns (uint64) {\n        // Simple linear search for now (could be optimized with mapping)\n        for (uint64 i = 1; i \u003c= _modelIdCounter; i++) {\n            if (keccak256(bytes(models[i])) == keccak256(bytes(modelName))) {\n                return i;\n            }\n        }\n        return _registerModel(modelName);\n    }\n\n    // =============================================================\n    //                        UUPS UPGRADE\n    // =============================================================\n\n    /**\n     * @dev Authorize upgrade (owner only)\n     */\n    function _authorizeUpgrade(\n        address newImplementation\n    ) internal override onlyOwner {}\n\n    /**\n     * @dev Get current contract version\n     */\n    function getVersion() external pure returns (string memory) {\n        return VERSION;\n    }\n\n    // =============================================================\n    //                      EMERGENCY FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Emergency function to recover ERC20 tokens\n     */\n    function emergencyWithdrawToken(\n        address token,\n        uint256 amount\n    ) external onlyOwner {\n        // Implement if needed for accidentally sent ERC20 tokens\n    }\n\n    /**\n     * @dev Receive ETH directly\n     */\n    receive() external payable {\n        // Accept ETH\n    }\n}\n",
    "abi": [
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "target",
            "type": "address"
          }
        ],
        "name": "AddressEmptyCode",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "ContractAlreadyExists",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "ContractNotFound",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "DuplicateHash",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "implementation",
            "type": "address"
          }
        ],
        "name": "ERC1967InvalidImplementation",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "ERC1967NonPayable",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "sender",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          },
          {
            "internalType": "address",
            "name": "owner",
            "type": "address"
          }
        ],
        "name": "ERC721IncorrectOwner",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "operator",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "ERC721InsufficientApproval",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "approver",
            "type": "address"
          }
        ],
        "name": "ERC721InvalidApprover",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "operator",
            "type": "address"
          }
        ],
        "name": "ERC721InvalidOperator",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "owner",
            "type": "address"
          }
        ],
        "name": "ERC721InvalidOwner",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "receiver",
            "type": "address"
          }
        ],
        "name": "ERC721InvalidReceiver",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "sender",
            "type": "address"
          }
        ],
        "name": "ERC721InvalidSender",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "ERC721NonexistentToken",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "FailedInnerCall",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "InvalidInitialization",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "InvalidInput",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "MaxSupplyExceeded",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "NotInitializing",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "owner",
            "type": "address"
          }
        ],
        "name": "OwnableInvalidOwner",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "account",
            "type": "address"
          }
        ],
        "name": "OwnableUnauthorizedAccount",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "TokenNotFound",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "UUPSUnauthorizedCallContext",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "slot",
            "type": "bytes32"
          }
        ],
        "name": "UUPSUnsupportedProxiableUUID",
        "type": "error"
      },
      {
        "inputs": [],
        "name": "UnauthorizedAccess",
        "type": "error"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "owner",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "approved",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "Approval",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "owner",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "operator",
            "type": "address"
          },
          {
            "indexed": false,
            "internalType": "bool",
            "name": "approved",
            "type": "bool"
          }
        ],
        "name": "ApprovalForAll",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "uint64",
            "name": "brandId",
            "type": "uint64"
          },
          {
            "indexed": false,
            "internalType": "string",
            "name": "brandName",
            "type": "string"
          }
        ],
        "name": "BrandRegistered",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          },
          {
            "indexed": true,
            "internalType": "bytes32",
            "name": "registryIdHash",
            "type": "bytes32"
          },
          {
            "indexed": true,
            "internalType": "bytes32",
            "name": "chassisHash",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "internalType": "bytes32",
            "name": "metadataHash",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "internalType": "uint32",
            "name": "timestamp",
            "type": "uint32"
          }
        ],
        "name": "ContractRegistered",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": false,
            "internalType": "uint64",
            "name": "version",
            "type": "uint64"
          }
        ],
        "name": "Initialized",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          },
          {
            "indexed": true,
            "internalType": "bytes32",
            "name": "oldHash",
            "type": "bytes32"
          },
          {
            "indexed": true,
            "internalType": "bytes32",
            "name": "newHash",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "internalType": "uint32",
            "name": "timestamp",
            "type": "uint32"
          }
        ],
        "name": "MetadataUpdated",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "uint64",
            "name": "modelId",
            "type": "uint64"
          },
          {
            "indexed": false,
            "internalType": "string",
            "name": "modelName",
            "type": "string"
          }
        ],
        "name": "ModelRegistered",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "previousOwner",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "newOwner",
            "type": "address"
          }
        ],
        "name": "OwnershipTransferred",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          },
          {
            "indexed": true,
            "internalType": "bool",
            "name": "active",
            "type": "bool"
          },
          {
            "indexed": false,
            "internalType": "uint32",
            "name": "timestamp",
            "type": "uint32"
          }
        ],
        "name": "StatusChanged",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "apiServer",
            "type": "address"
          },
          {
            "indexed": false,
            "internalType": "string",
            "name": "metadataUrl",
            "type": "string"
          }
        ],
        "name": "SystemConfigured",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "from",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "to",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "Transfer",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "implementation",
            "type": "address"
          }
        ],
        "name": "Upgraded",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          },
          {
            "indexed": true,
            "internalType": "bytes32",
            "name": "chassis",
            "type": "bytes32"
          },
          {
            "indexed": true,
            "internalType": "bytes32",
            "name": "licensePlate",
            "type": "bytes32"
          },
          {
            "indexed": false,
            "internalType": "uint128",
            "name": "totalValue",
            "type": "uint128"
          },
          {
            "indexed": false,
            "internalType": "uint64",
            "name": "brandId",
            "type": "uint64"
          },
          {
            "indexed": false,
            "internalType": "uint64",
            "name": "modelId",
            "type": "uint64"
          }
        ],
        "name": "VehicleTracked",
        "type": "event"
      },
      {
        "inputs": [],
        "name": "MAX_SUPPLY",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "UPGRADE_INTERFACE_VERSION",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "VERSION",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "apiServerAddress",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "name": "approve",
        "outputs": [],
        "stateMutability": "pure",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "owner",
            "type": "address"
          }
        ],
        "name": "balanceOf",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint64",
            "name": "",
            "type": "uint64"
          }
        ],
        "name": "brands",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ],
        "name": "chassisHashToTokenId",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "name": "contracts",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "registryId",
            "type": "bytes32"
          },
          {
            "internalType": "bytes32",
            "name": "contractNumber",
            "type": "bytes32"
          },
          {
            "internalType": "uint32",
            "name": "contractDate",
            "type": "uint32"
          },
          {
            "internalType": "bytes32",
            "name": "metadataHash",
            "type": "bytes32"
          },
          {
            "internalType": "uint32",
            "name": "timestamp",
            "type": "uint32"
          },
          {
            "internalType": "address",
            "name": "registeredBy",
            "type": "address"
          },
          {
            "internalType": "bool",
            "name": "active",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "string",
            "name": "registryId",
            "type": "string"
          }
        ],
        "name": "doesContractExist",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "metadataHash",
            "type": "bytes32"
          }
        ],
        "name": "doesHashExist",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "name": "emergencyWithdrawToken",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "offset",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "limit",
            "type": "uint256"
          }
        ],
        "name": "getActiveContracts",
        "outputs": [
          {
            "internalType": "uint256[]",
            "name": "tokenIds",
            "type": "uint256[]"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "getApproved",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint64",
            "name": "brandId",
            "type": "uint64"
          }
        ],
        "name": "getBrandName",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "getContract",
        "outputs": [
          {
            "components": [
              {
                "internalType": "bytes32",
                "name": "registryId",
                "type": "bytes32"
              },
              {
                "internalType": "bytes32",
                "name": "contractNumber",
                "type": "bytes32"
              },
              {
                "internalType": "uint32",
                "name": "contractDate",
                "type": "uint32"
              },
              {
                "internalType": "bytes32",
                "name": "metadataHash",
                "type": "bytes32"
              },
              {
                "internalType": "uint32",
                "name": "timestamp",
                "type": "uint32"
              },
              {
                "internalType": "address",
                "name": "registeredBy",
                "type": "address"
              },
              {
                "internalType": "bool",
                "name": "active",
                "type": "bool"
              }
            ],
            "internalType": "struct VFinanceRegistry.ContractRecord",
            "name": "",
            "type": "tuple"
          },
          {
            "components": [
              {
                "internalType": "bytes32",
                "name": "chassis",
                "type": "bytes32"
              },
              {
                "internalType": "bytes32",
                "name": "licensePlate",
                "type": "bytes32"
              },
              {
                "internalType": "uint128",
                "name": "totalValue",
                "type": "uint128"
              },
              {
                "internalType": "uint64",
                "name": "brandId",
                "type": "uint64"
              },
              {
                "internalType": "uint64",
                "name": "modelId",
                "type": "uint64"
              }
            ],
            "internalType": "struct VFinanceRegistry.VehicleCore",
            "name": "",
            "type": "tuple"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "string",
            "name": "chassis",
            "type": "string"
          }
        ],
        "name": "getContractByChassis",
        "outputs": [
          {
            "components": [
              {
                "internalType": "bytes32",
                "name": "registryId",
                "type": "bytes32"
              },
              {
                "internalType": "bytes32",
                "name": "contractNumber",
                "type": "bytes32"
              },
              {
                "internalType": "uint32",
                "name": "contractDate",
                "type": "uint32"
              },
              {
                "internalType": "bytes32",
                "name": "metadataHash",
                "type": "bytes32"
              },
              {
                "internalType": "uint32",
                "name": "timestamp",
                "type": "uint32"
              },
              {
                "internalType": "address",
                "name": "registeredBy",
                "type": "address"
              },
              {
                "internalType": "bool",
                "name": "active",
                "type": "bool"
              }
            ],
            "internalType": "struct VFinanceRegistry.ContractRecord",
            "name": "",
            "type": "tuple"
          },
          {
            "components": [
              {
                "internalType": "bytes32",
                "name": "chassis",
                "type": "bytes32"
              },
              {
                "internalType": "bytes32",
                "name": "licensePlate",
                "type": "bytes32"
              },
              {
                "internalType": "uint128",
                "name": "totalValue",
                "type": "uint128"
              },
              {
                "internalType": "uint64",
                "name": "brandId",
                "type": "uint64"
              },
              {
                "internalType": "uint64",
                "name": "modelId",
                "type": "uint64"
              }
            ],
            "internalType": "struct VFinanceRegistry.VehicleCore",
            "name": "",
            "type": "tuple"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "metadataHash",
            "type": "bytes32"
          }
        ],
        "name": "getContractByHash",
        "outputs": [
          {
            "components": [
              {
                "internalType": "bytes32",
                "name": "registryId",
                "type": "bytes32"
              },
              {
                "internalType": "bytes32",
                "name": "contractNumber",
                "type": "bytes32"
              },
              {
                "internalType": "uint32",
                "name": "contractDate",
                "type": "uint32"
              },
              {
                "internalType": "bytes32",
                "name": "metadataHash",
                "type": "bytes32"
              },
              {
                "internalType": "uint32",
                "name": "timestamp",
                "type": "uint32"
              },
              {
                "internalType": "address",
                "name": "registeredBy",
                "type": "address"
              },
              {
                "internalType": "bool",
                "name": "active",
                "type": "bool"
              }
            ],
            "internalType": "struct VFinanceRegistry.ContractRecord",
            "name": "",
            "type": "tuple"
          },
          {
            "components": [
              {
                "internalType": "bytes32",
                "name": "chassis",
                "type": "bytes32"
              },
              {
                "internalType": "bytes32",
                "name": "licensePlate",
                "type": "bytes32"
              },
              {
                "internalType": "uint128",
                "name": "totalValue",
                "type": "uint128"
              },
              {
                "internalType": "uint64",
                "name": "brandId",
                "type": "uint64"
              },
              {
                "internalType": "uint64",
                "name": "modelId",
                "type": "uint64"
              }
            ],
            "internalType": "struct VFinanceRegistry.VehicleCore",
            "name": "",
            "type": "tuple"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "string",
            "name": "registryId",
            "type": "string"
          }
        ],
        "name": "getContractByRegistryId",
        "outputs": [
          {
            "components": [
              {
                "internalType": "bytes32",
                "name": "registryId",
                "type": "bytes32"
              },
              {
                "internalType": "bytes32",
                "name": "contractNumber",
                "type": "bytes32"
              },
              {
                "internalType": "uint32",
                "name": "contractDate",
                "type": "uint32"
              },
              {
                "internalType": "bytes32",
                "name": "metadataHash",
                "type": "bytes32"
              },
              {
                "internalType": "uint32",
                "name": "timestamp",
                "type": "uint32"
              },
              {
                "internalType": "address",
                "name": "registeredBy",
                "type": "address"
              },
              {
                "internalType": "bool",
                "name": "active",
                "type": "bool"
              }
            ],
            "internalType": "struct VFinanceRegistry.ContractRecord",
            "name": "",
            "type": "tuple"
          },
          {
            "components": [
              {
                "internalType": "bytes32",
                "name": "chassis",
                "type": "bytes32"
              },
              {
                "internalType": "bytes32",
                "name": "licensePlate",
                "type": "bytes32"
              },
              {
                "internalType": "uint128",
                "name": "totalValue",
                "type": "uint128"
              },
              {
                "internalType": "uint64",
                "name": "brandId",
                "type": "uint64"
              },
              {
                "internalType": "uint64",
                "name": "modelId",
                "type": "uint64"
              }
            ],
            "internalType": "struct VFinanceRegistry.VehicleCore",
            "name": "",
            "type": "tuple"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "metadataHash",
            "type": "bytes32"
          }
        ],
        "name": "getMetadataUrl",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "string",
            "name": "registryId",
            "type": "string"
          }
        ],
        "name": "getMetadataUrlByRegistryId",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint64",
            "name": "modelId",
            "type": "uint64"
          }
        ],
        "name": "getModelName",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "getVersion",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "pure",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "string",
            "name": "name",
            "type": "string"
          },
          {
            "internalType": "string",
            "name": "symbol",
            "type": "string"
          },
          {
            "internalType": "string",
            "name": "_metadataBaseUrl",
            "type": "string"
          },
          {
            "internalType": "address",
            "name": "_apiServerAddress",
            "type": "address"
          }
        ],
        "name": "initialize",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "owner",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "operator",
            "type": "address"
          }
        ],
        "name": "isApprovedForAll",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "metadataBaseUrl",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ],
        "name": "metadataHashToTokenId",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint64",
            "name": "",
            "type": "uint64"
          }
        ],
        "name": "models",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "name",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "owner",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "ownerOf",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "proxiableUUID",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "string",
            "name": "brandName",
            "type": "string"
          }
        ],
        "name": "registerBrand",
        "outputs": [
          {
            "internalType": "uint64",
            "name": "brandId",
            "type": "uint64"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "string",
            "name": "registryId",
            "type": "string"
          },
          {
            "internalType": "string",
            "name": "contractNumber",
            "type": "string"
          },
          {
            "internalType": "uint32",
            "name": "contractDate",
            "type": "uint32"
          },
          {
            "internalType": "string",
            "name": "chassis",
            "type": "string"
          },
          {
            "internalType": "string",
            "name": "licensePlate",
            "type": "string"
          },
          {
            "internalType": "uint128",
            "name": "totalValue",
            "type": "uint128"
          },
          {
            "internalType": "string",
            "name": "brandName",
            "type": "string"
          },
          {
            "internalType": "string",
            "name": "modelName",
            "type": "string"
          }
        ],
        "name": "registerContract",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          },
          {
            "internalType": "bytes32",
            "name": "metadataHash",
            "type": "bytes32"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "string",
            "name": "modelName",
            "type": "string"
          }
        ],
        "name": "registerModel",
        "outputs": [
          {
            "internalType": "uint64",
            "name": "modelId",
            "type": "uint64"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ],
        "name": "registryIdHashToTokenId",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "renounceOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "from",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "to",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "safeTransferFrom",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "from",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "to",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          },
          {
            "internalType": "bytes",
            "name": "data",
            "type": "bytes"
          }
        ],
        "name": "safeTransferFrom",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          },
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "name": "setApprovalForAll",
        "outputs": [],
        "stateMutability": "pure",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "bytes4",
            "name": "interfaceId",
            "type": "bytes4"
          }
        ],
        "name": "supportsInterface",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "symbol",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "tokenURI",
        "outputs": [
          {
            "internalType": "string",
            "name": "",
            "type": "string"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "from",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "to",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "transferFrom",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "newOwner",
            "type": "address"
          }
        ],
        "name": "transferOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          },
          {
            "internalType": "bytes32",
            "name": "newMetadataHash",
            "type": "bytes32"
          }
        ],
        "name": "updateMetadataHash",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "string",
            "name": "newMetadataBaseUrl",
            "type": "string"
          },
          {
            "internalType": "address",
            "name": "newApiServerAddress",
            "type": "address"
          }
        ],
        "name": "updateServerConfig",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          },
          {
            "internalType": "bool",
            "name": "active",
            "type": "bool"
          }
        ],
        "name": "updateStatus",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "newImplementation",
            "type": "address"
          },
          {
            "internalType": "bytes",
            "name": "data",
            "type": "bytes"
          }
        ],
        "name": "upgradeToAndCall",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "name": "vehicleCores",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "chassis",
            "type": "bytes32"
          },
          {
            "internalType": "bytes32",
            "name": "licensePlate",
            "type": "bytes32"
          },
          {
            "internalType": "uint128",
            "name": "totalValue",
            "type": "uint128"
          },
          {
            "internalType": "uint64",
            "name": "brandId",
            "type": "uint64"
          },
          {
            "internalType": "uint64",
            "name": "modelId",
            "type": "uint64"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "stateMutability": "payable",
        "type": "receive"
      }
    ],
    "bytecode": "60a08060405234602957306080526139eb908161002f823960805181818161103601526111640152f35b600080fdfe6080604052600436101561001b575b361561001957600080fd5b005b60003560e01c806301ffc9a71461033c57806306fdde031461033757806307f6370014610332578063081812fc1461032d578063095ea7b3146103285780630d8e6e2c146102565780630df205f01461032357806318160ddd1461031e5780631ee667701461031957806323b872dd1461031457806331d1cbda1461030f57806332cb6b0c1461030a578063387008c21461030557806342842e0e14610300578063456830ff146102fb578063474da79a146102f657806349f3f1a6146102f15780634f1ef286146102ec57806352d1902d146102e75780635c6d8da1146102e25780636352211e146102dd57806365950af4146102d85780636933a44c146102d35780636ebc8c86146102ce57806370a08231146102c9578063715018a6146102c4578063861d297f1461027457806389d3e2031461029c5780638da5cb5b146102bf57806395d89b41146102ba5780639dfdc7de146102b55780639f9aab6f146102b0578063a22cb465146102ab578063a35614d5146102a6578063a4c3b091146102a1578063a636733c1461029c578063a69e14b114610297578063abb47e1014610292578063ad3cb1cc1461028d578063b88d4fde14610288578063bc33768e14610283578063c87b56dd1461027e578063d54f9a7414610279578063ddb3069c14610274578063e985e9c51461026f578063ec4358ea1461026a578063eed47f2e14610265578063f2fde38b14610260578063f672cbc51461025b578063ffa1ad74146102565763fffc02bc0361000e57611b46565b610727565b611ae2565b611ab9565b611a26565b6119f1565b611968565b61145d565b61191d565b611885565b61185c565b61180e565b6117c8565b61179c565b611770565b6114b1565b61174e565b61166e565b611623565b611608565b6115d4565b611520565b6114ea565b6113d0565b61137b565b611319565b6112c1565b61125a565b61122a565b6111aa565b611151565b610ff7565b610f24565b610dd4565b610c97565b610c6f565b610b7b565b610b4e565b6109dc565b610894565b610831565b610801565b6107c8565b6106f0565b610679565b610519565b610422565b610358565b6001600160e01b031981160361035357565b600080fd5b3461035357602036600319011261035357602060043561037781610341565b63ffffffff60e01b166380ac58cd60e01b81149081156103b5575b81156103a4575b506040519015158152f35b6301ffc9a760e01b14905038610399565b635b5e139f60e01b81149150610392565b60005b8381106103d95750506000910152565b81810151838201526020016103c9565b90602091610402815180928185528580860191016103c6565b601f01601f1916010190565b90602061041f9281815201906103e9565b90565b3461035357600080600319360112610516576040519080600080516020613896833981519152805461045381610e54565b808652926020926001928084169081156104e75750600114610490575b61048c8761048081890382610932565b6040519182918261040e565b0390f35b815293507f37c58c799b6609234b945e882912ee9ad34948a1dfaa20a97485e1a7752bbf815b8385106104d4575050505081016020016104808261048c3880610470565b80548686018401529382019381016104b6565b91505086955061048c9693506020925061048094915060ff191682840152151560051b82010192933880610470565b80fd5b346103535760408060031936011261035357600654602435919060043590336001600160a01b039182161415908161065d575b5061064c5780158015610640575b61062f57821561061e57610578836000526002602052604060002090565b5461060d577f886980e9630c81aec383adb83bdf9ec93f47b6a360a6e4f9ad631813ea336c5c60036105b4836000526000602052604060002090565b01549260006105cd856000526002602052604060002090565b558460036105e5856000526000602052604060002090565b0155826105fc866000526002602052604060002090565b555163ffffffff42168152602090a4005b8151631fc0b7e760e01b8152600490fd5b815163b4fa3fb360e01b8152600490fd5b8151630cbdb7b360e41b8152600490fd5b5060055481101561055a565b8151631a27eac360e11b8152600490fd5b90506000805160206138b683398151915254163314153861054c565b346103535760203660031901126103535760043561069681612f51565b50600052600080516020613956833981519152602052602060018060a01b0360406000205416604051908152f35b600435906001600160a01b038216820361035357565b602435906001600160a01b038216820361035357565b34610353576040366003190112610353576107096106c4565b5060405162461bcd60e51b81528061072360048201611b72565b0390fd5b346103535760003660031901126103535761048c60405161074781610917565b60058152640322e302e360dc1b60208201526040519182916020835260208301906103e9565b9181601f84011215610353578235916001600160401b038311610353576020838186019501011161035357565b602060031982011261035357600435906001600160401b038211610353576107c49160040161076d565b9091565b34610353576107e06107d93661079a565b369161098a565b60208151910120600052600160205260206040600020541515604051908152f35b3461035357600036600319011261035357600554600019810190811161082c57602090604051908152f35b611bb7565b3461035357602036600319011261035357600435600052600260205260206040600020541515604051908152f35b6060906003190112610353576001600160a01b0390600435828116810361035357916024359081168103610353579060443590565b34610353576100196108a53661085f565b91611be9565b634e487b7160e01b600052604160045260246000fd5b60e081019081106001600160401b038211176108dc57604052565b6108ab565b60a081019081106001600160401b038211176108dc57604052565b602081019081106001600160401b038211176108dc57604052565b604081019081106001600160401b038211176108dc57604052565b90601f801991011681019081106001600160401b038211176108dc57604052565b60405190610960826108c1565b565b60405190610960826108e1565b6001600160401b0381116108dc57601f01601f191660200190565b9291926109968261096f565b916109a46040519384610932565b829481845281830111610353578281602093846000960137010152565b9080601f830112156103535781602061041f9335910161098a565b34610353576040366003190112610353576001600160401b0360043581811161035357610a0d9036906004016109c1565b90610a166106da565b90610a1f612f99565b82519081116108dc57610a3c81610a37600754610e54565b611d6e565b602080601f8311600114610ac8575091610a8082610ab89360008051602061391683398151915295600091610abd575b508160011b916000199060031b1c19161790565b6007555b600680546001600160a01b0319166001600160a01b0383161790556040516001600160a01b0390911693909182918261040e565b0390a2005b905086015138610a6c565b600760005290601f1983166000805160206138d6833981519152926000905b828210610b3657505092600080516020613916833981519152949260019282610ab89610610b1d575b5050811b01600755610a84565b87015160001960f88460031b161c191690553880610b10565b80600185968294968b01518155019501930190610ae7565b34610353576000366003190112610353576020604051629896808152f35b60243590811515820361035357565b3461035357604036600319011261035357600435610b97610b6c565b600654909190336001600160a01b0391821614159081610c53575b50610c415780158015610c35575b610c23576000818152602081905260409020600401805460ff60c01b191683151560c01b60ff60c01b161790557ff3af971fc7f1836a845935ae73f7a6d6c219a218fad3a750456741df99e0578160206040519363ffffffff42168552151593a3005b604051630cbdb7b360e41b8152600490fd5b50600554811015610bc0565b604051631a27eac360e11b8152600490fd5b90506000805160206138b6833981519152541633141538610bb2565b3461035357610019610c803661085f565b9060405192610c8e846108fc565b60008452612b63565b3461035357610cc1610ca83661079a565b610cb06120fb565b50610cb9612133565b50369161098a565b602081519101206000908152600160205260408120548015610da557815280602052610d01610cfb6040808420936003602052209261215e565b916121c2565b6040805183518152602080850151818301528483015163ffffffff90811683850152606080870151818501526080808801519092168285015260a0808801516001600160a01b03169085015260c096870151151596840196909652845160e084015290840151610100830152918301516001600160801b0316610120820152928201516001600160401b039081166101408501529101511661016082015261018090f35b604051633b56498960e21b8152600490fd5b600052600080516020613936833981519152602052604060002090565b3461035357602036600319011261035357600435600052600060205260e0604060002060ff81549160018101549063ffffffff908160028201541660046003830154920154936040519687526020870152604086015260608501528116608084015260018060a01b038160201c1660a084015260c01c16151560c0820152f35b90600182811c92168015610e84575b6020831014610e6e57565b634e487b7160e01b600052602260045260246000fd5b91607f1691610e63565b805460009392610e9d82610e54565b91828252602093600191600181169081600014610f055750600114610ec4575b5050505050565b90939495506000929192528360002092846000945b838610610ef157505050500101903880808080610ebd565b805485870183015294019385908201610ed9565b60ff19168685015250505090151560051b010191503880808080610ebd565b34610353576000806003193601126105165760405190808260075491610f4983610e54565b9283835260209460019186600182169182600014610fd5575050600114610f8d575b5050610f7992500383610932565b61048c6040519282849384528301906103e9565b90859250600782526000805160206138d68339815191525b858310610fbd575050610f7993508201013880610f6b565b80548389018501528794508693909201918101610fa5565b9250935050610f7994915060ff191682840152151560051b8201013880610f6b565b60403660031901126103535761100b6106c4565b6024356001600160401b0381116103535761102a9036906004016109c1565b6001600160a01b0391907f00000000000000000000000000000000000000000000000000000000000000008316308114908115611135575b50611123576020600493611074612f99565b6040516352d1902d60e01b8152948591829086165afa600093816110f2575b506110b957604051634c9c8ce360e01b81526001600160a01b0383166004820152602490fd5b906000805160206138f683398151915283036110d9576100199250613601565b604051632a87526960e21b815260048101849052602490fd5b61111591945060203d60201161111c575b61110d8183610932565b810190612fd2565b9238611093565b503d611103565b60405163703e46dd60e11b8152600490fd5b9050836000805160206138f68339815191525416141538611062565b34610353576000366003190112610353577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031630036111235760206040516000805160206138f68339815191528152f35b34610353576080366003190112610353576001600160401b03600435818111610353576111db9036906004016109c1565b90602435818111610353576111f49036906004016109c1565b906044359081116103535761120d9036906004016109c1565b606435916001600160a01b0383168303610353576100199361220d565b34610353576020366003190112610353576020611248600435612f51565b6040516001600160a01b039091168152f35b3461035357602036600319011261035357600435600052600360205260a06040600020805490600260018201549101549060405192835260208301526001600160801b03811660408301526001600160401b038160801c16606083015260c01c6080820152f35b34610353576020366003190112610353576112da6120fb565b506112e3612133565b5060006004358152600260205260408120548015610da557815280602052610d01610cfb6040808420936003602052209261215e565b34610353576020366003190112610353576004356113356120fb565b5061133e612133565b508015801561136f575b610c2357600052600060205260406000206003602052610d01610cfb60406000209261215e565b50600554811015611348565b34610353576020366003190112610353576113946106c4565b6001600160a01b038116156113b7576113ae60209161268d565b54604051908152f35b6040516322718ad960e21b815260006004820152602490fd5b3461035357600080600319360112610516576113ea612f99565b6000805160206138b683398151915280546001600160a01b0319811690915581906001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b6020906003190112610353576004356001600160401b03811681036103535790565b34610353576001600160401b036114733661143b565b16600052600a60205261048c61149661149d604060002060405192838092610e8e565b0382610932565b6040519182916020835260208301906103e9565b34610353576001600160401b036114c73661143b565b16600052600860205261048c61149661149d604060002060405192838092610e8e565b34610353576000366003190112610353576000805160206138b6833981519152546040516001600160a01b039091168152602090f35b3461035357600080600319360112610516576040519080600080516020613996833981519152805461155181610e54565b808652926020926001928084169081156104e7575060011461157d5761048c8761048081890382610932565b815293507ff4bad0a69248f59680a4f2b3000328cec71a413447c96781cfe5996daa8c456e5b8385106115c1575050505081016020016104808261048c3880610470565b80548686018401529382019381016115a3565b346103535760206115f76115f26115ea3661079a565b6107d9612f99565b61316f565b6001600160401b0360405191168152f35b346103535760206115f761161e6115ea3661079a565b61300d565b346103535760403660031901126103535761163c6106c4565b50610709610b6c565b6044359063ffffffff8216820361035357565b60a435906001600160801b038216820361035357565b34610353576101003660031901126103535760046001600160401b038135818111610353576116a0903690840161076d565b91602435818111610353576116b8903690860161076d565b6116c3929192611645565b606435838111610353576116da903690890161076d565b608492919235858111610353576116f49036908b0161076d565b9390926116ff611658565b9560c435888111610353578c6117179136910161076d565b99909860e4359081116103535761173c9d6117349136910161076d565b9c909b6126c6565b60408051928352602083019190915290f35b34610353576040366003190112610353576117676106c4565b50610019612f99565b346103535760203660031901126103535760043560005260026020526020604060002054604051908152f35b346103535760203660031901126103535760043560005260046020526020604060002054604051908152f35b346103535760003660031901126103535761048c6040516117e881610917565b60058152640352e302e360dc1b60208201526040519182916020835260208301906103e9565b34610353576080366003190112610353576118276106c4565b61182f6106da565b606435916001600160401b038311610353576118526100199336906004016109c1565b9160443591612b63565b34610353576000366003190112610353576006546040516001600160a01b039091168152602090f35b346103535760203660031901126103535760043580158015611911575b610c2357600052600060205261048c6118c2600360406000200154613563565b610480601060405180936118d860208301612c69565b6f05ec2e0d25edacae8c2c8c2e8c25e60f60831b815261190182518093602087850191016103c6565b0103600f19810184520182610932565b506005548110156118a2565b346103535761192e610ca83661079a565b602081519101206000908152600460205260408120548015610da557815280602052610d01610cfb6040808420936003602052209261215e565b3461035357604036600319011261035357602060ff6119e56119886106c4565b6119ce6119936106da565b6001600160a01b0390921660009081527f80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab00793056020526040902090565b9060018060a01b0316600052602052604060002090565b54166040519015158152f35b346103535760203660031901126103535761048c611a10600435613563565b61149d601060405180936118d860208301612c69565b3461035357611a376107d93661079a565b6020815191012060005260016020526040600020548015610da557600052600060205261048c611aab610480611a74600360406000200154613563565b604051928391611aa5611a8960208501612c69565b6f05ec2e0d25edacae8c2c8c2e8c25e60f60831b815260100190565b90612ce6565b03601f198101835282610932565b3461035357602036600319011261035357610019611ad56106c4565b611add612f99565b612cfd565b3461035357604036600319011261035357611b01602435600435612e01565b6040518091602080830160208452825180915260206040850193019160005b828110611b2f57505050500390f35b835185528695509381019392810192600101611b20565b346103535760203660031901126103535760043560005260016020526020604060002054604051908152f35b60809060208152602460208201527f526567697374727920746f6b656e7320617265206e6f6e2d7472616e7366657260408201526361626c6560e01b60608201520190565b634e487b7160e01b600052601160045260246000fd5b60001981019190821161082c57565b9190820391821161082c57565b6001600160a01b03908282168015611d5557846000526000805160206139368339815191526020528260406000205416151580611d4d575b611d34578490611c8d611c43611c3684610db7565b546001600160a01b031690565b9533611d24575b8587169687611ce4575b50611c5e8161268d565b60018154019055611c6e84610db7565b80546001600160a01b0319166001600160a01b03909216919091179055565b847fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef600080a41691828203611cc157505050565b60649350604051926364283d7b60e01b8452600484015260248301526044820152fd5b60008581526000805160206139568339815191526020526040902080546001600160a01b0319169055611d169061268d565b805460001901905538611c54565b611d2f843389613720565b611c4a565b60405162461bcd60e51b81528061072360048201611b72565b506001611c21565b604051633250574960e11b815260006004820152602490fd5b601f8111611d7a575050565b60009060076000526000805160206138d6833981519152906020601f850160051c83019410611dc4575b601f0160051c01915b828110611db957505050565b818155600101611dad565b9092508290611da4565b601f8111611dda575050565b6000906000805160206138968339815191526000527f37c58c799b6609234b945e882912ee9ad34948a1dfaa20a97485e1a7752bbf81906020601f850160051c83019410611e43575b601f0160051c01915b828110611e3857505050565b818155600101611e2c565b9092508290611e23565b601f8111611e59575050565b6000906000805160206139968339815191526000527ff4bad0a69248f59680a4f2b3000328cec71a413447c96781cfe5996daa8c456e906020601f850160051c83019410611ec2575b601f0160051c01915b828110611eb757505050565b818155600101611eab565b9092508290611ea2565b90601f8111611eda57505050565b6000916000526020600020906020601f850160051c83019410611f18575b601f0160051c01915b828110611f0d57505050565b818155600101611f01565b9092508290611ef8565b9081516001600160401b0381116108dc57611f4281610a37600754610e54565b602080601f8311600114611f8557508190611f759394600092611f7a575b50508160011b916000199060031b1c19161790565b600755565b015190503880611f60565b90601f19831694611fa660076000526000805160206138d683398151915290565b926000905b878210611fe3575050836001959610611fca575b505050811b01600755565b015160001960f88460031b161c19169055388080611fbf565b80600185968294968601518155019501930190611fab565b9081516001600160401b0381116108dc576000805160206139968339815191529061202f8161202a8454610e54565b611e4d565b602080601f831160011461206657508190612062939495600092611f7a5750508160011b916000199060031b1c19161790565b9055565b90601f198316956120a66000805160206139968339815191526000527ff4bad0a69248f59680a4f2b3000328cec71a413447c96781cfe5996daa8c456e90565b926000905b8882106120e3575050836001959697106120ca575b505050811b019055565b015160001960f88460031b161c191690553880806120c0565b806001859682949686015181550195019301906120ab565b60405190612108826108c1565b8160c06000918281528260208201528260408201528260608201528260808201528260a08201520152565b60405190612140826108e1565b60006080838281528260208201528260408201528260608201520152565b9060405161216b816108c1565b60c060ff82948054845260018101546020850152600463ffffffff91826002820154166040870152600381015460608701520154908116608085015260018060a01b038160201c1660a0850152821c161515910152565b906040516121cf816108e1565b608060028294805484526001810154602085015201546001600160801b03811660408401526001600160401b0381831c16606084015260c01c910152565b9290916000805160206139768339815191529283549460ff8660401c1615956001600160401b03811680159081612313575b6001149081612309575b159081612300575b506122ee5767ffffffffffffffff191660011790945561227593856122c457612474565b61227b57565b600080516020613976833981519152805460ff60401b19169055604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a1565b600080516020613976833981519152805460ff60401b191668010000000000000000179055612474565b60405163f92ee8a960e01b8152600490fd5b90501538612251565b303b159150612249565b88915061223f565b6040519061232882610917565b6006825265544f594f544160d01b6020830152565b6040519061234a82610917565b6005825264484f4e444160d81b6020830152565b6040519061236b82610917565b600a8252692b27a625a9aba0a3a2a760b11b6020830152565b6040519061239182610917565b60048252631192505560e21b6020830152565b604051906123b182610917565b600982526810d211559493d3115560ba1b6020830152565b604051906123d682610917565b60048252631193d49160e21b6020830152565b604051906123f682610917565b60068252652724a9a9a0a760d11b6020830152565b6040519061241882610917565b60078252664859554e44414960c81b6020830152565b6040519061243b82610917565b60078252661491539055531560ca1b6020830152565b6040519061245e82610917565b600782526614115551d153d560ca1b6020830152565b92919261247f6136a8565b6124876136a8565b80516001600160401b0381116108dc57600080516020613896833981519152916124ba826124b58554610e54565b611dce565b602090816001601f8511146125e15750926125058361250c946125dc97946000805160206139168339815191529997600092611f7a5750508160011b916000199060031b1c19161790565b9055611ffb565b61251533612fe1565b61251d6136a8565b61252684611f22565b600680546001600160a01b0319166001600160a01b03831617905561254b6001600555565b61255661161e61231b565b5061256261161e61233d565b5061256e61161e61235e565b5061257a61161e612384565b5061258661161e6123a4565b5061259261161e6123c9565b5061259e61161e6123e9565b506125aa61161e61240b565b506125b661161e61242e565b506125c261161e612451565b506040516001600160a01b0390911693909182918261040e565b0390a2565b6000805160206138968339815191526000529190601f1984167f37c58c799b6609234b945e882912ee9ad34948a1dfaa20a97485e1a7752bbf81936000905b828210612675575050936125dc96936000805160206139168339815191529896936001938361250c981061265c575b505050811b019055611ffb565b015160001960f88460031b161c1916905538808061264f565b80600186978294978701518155019601940190612620565b6001600160a01b031660009081527f80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab00793036020526040902090565b9b98959d9c96979991909a9293949a60018060a01b0380600654163314159081612a8d575b50610c415780158f8115612a84575b50612a72576005549c629896808e11612a60578f9961274c61273f8f61274461273f61272e61273f9761275499369161098a565b9889516020809b01209c369161098a565b613292565b9d369161098a565b9c369161098a565b9a612769856000526001602052604060002090565b54612a4e576127948f61277e9036908461098a565b8381519101206000526004602052604060002090565b54612a4e578a868e6127a581612aa9565b600555604080518681018a8152602081018f905260e09490941b6001600160e01b0319169184019190915260448301939093526064820152426084820152908060a4830103601f19810182526127fb9082610932565b5190209e8f612814906000526002602052604060002090565b54612a3c578f939a6128298f9c968d976132a6565b996128339161333a565b9961283e86306133c5565b4263ffffffff169761284e610953565b8881528581019290925263ffffffff1660408201526060810185905263ffffffff881660808201523360a0820152600160c0820152612897866000526000602052604060002090565b906128a191612ab8565b6128a9610962565b8c81528381018e90526001600160801b03891660408201526001600160401b038a1660608201526001600160401b038b1660808201526128f3866000526003602052604060002090565b9061294a919060029080518355602081015160018401556001600160801b0360408201511660608201519160806001600160401b0360c01b91015160c01b16916001600160401b0360801b9060801b161717910155565b8461295f876000526001602052604060002090565b5584612975856000526002602052604060002090565b558461298236838561098a565b84815191012061299c906000526004602052604060002090565b5536906129a89261098a565b80519101206040805192835263ffffffff959095166020830152937f08763d7ed3c1fd5bc57e914d68af9baaed2ab99ca4d797aca811079add788b9291a4604080516001600160801b0390921682526001600160401b03928316602083015291909216908201528060608101037fe3de43c7d5e7c3deb7350fadd7772fbadda69da2d4ab42b3ecbc95446f2aed2a91a49190565b604051631fc0b7e760e01b8152600490fd5b60405163e8dc2ba560e01b8152600490fd5b604051638a164f6360e01b8152600490fd5b60405163b4fa3fb360e01b8152600490fd5b9050158f6126fa565b90506000805160206138b68339815191525416331415386126eb565b600019811461082c5760010190565b60c0610960928051835560208101516001840155612b22600463ffffffff94612afa86604086015116600283019063ffffffff1663ffffffff19825416179055565b606084015160038201550193608083015116849063ffffffff1663ffffffff19825416179055565b60a081015183549183015160ff60c01b90151560c01b1660209190911b600190931b63ffffffff190192831692199091169190911760ff60c01b1916179055565b91929092612b72818585611be9565b833b612b7f575b50505050565b612ba4916020916040519384928392630a85bd0160e11b9788855233600486016134db565b038160006001600160a01b0388165af160009181612c38575b50612bfc5782612bcb61350c565b8051919082612bf557604051633250574960e11b81526001600160a01b0383166004820152602490fd5b9050602001fd5b6001600160e01b03191603612c15575038808080612b79565b604051633250574960e11b81526001600160a01b03919091166004820152602490fd5b612c5b91925060203d602011612c62575b612c538183610932565b8101906134c6565b9038612bbd565b503d612c49565b60075460009291612c7982610e54565b91600190818116908115612cd35750600114612c9457505050565b909192935060076000526000805160206138d6833981519152906000915b848310612cc0575050500190565b8181602092548587015201920191612cb2565b60ff191683525050811515909102019150565b90612cf9602092828151948592016103c6565b0190565b6001600160a01b03908116908115612d58576000805160206138b683398151915280546001600160a01b031981168417909155167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3565b604051631e4fbdf760e01b815260006004820152602490fd5b6001600160401b0381116108dc5760051b60200190565b604051612d94816108fc565b60008152906000368137565b90612daa82612d71565b612db76040519182610932565b8281528092612dc8601f1991612d71565b0190602036910137565b634e487b7160e01b600052603260045260246000fd5b8051821015612dfc5760209160051b010190565b612dd2565b81158015612f47575b612a7257612e19600554611bcd565b91600060015b84811115612f06575080831015612efa5782612e3a91611bdc565b90808211612ef2575b50612e4d81612da0565b60009160009060015b8681111580612ee9575b15612edf57612e896004612e7e836000526000602052604060002090565b015460c01c60ff1690565b612e9c575b612e9790612aa9565b612e56565b9385811015612eba575b612eb2612e9791612aa9565b949050612e8e565b91612eb2612ed68287612ed0612e979589612de8565b52612aa9565b93915050612ea6565b5050509250505090565b50818310612e60565b905038612e43565b5050505061041f612d88565b612f1f6004612e7e836000526000602052604060002090565b612f32575b612f2d90612aa9565b612e1f565b90612f3f612f2d91612aa9565b919050612f24565b5060648211612e0a565b600081815260008051602061393683398151915260205260409020546001600160a01b0316908115612f81575090565b60249060405190637e27328960e01b82526004820152fd5b6000805160206138b6833981519152546001600160a01b03163303612fba57565b60405163118cdaa760e01b8152336004820152602490fd5b90816020910312610353575190565b61096090612fed6136a8565b611add6136a8565b6001600160401b0380911690811461082c5760010190565b6009546001600160401b0391613024838316612ff5565b9280841680936001600160401b0319161760095582600052602090600860205260406000209183519182116108dc57613067826130618554610e54565b85611ecc565b602090601f83116001146130dc5750916130bd827fd6a561f68236f1785e9c45009eba5ac6bfb0ae92da53a5dbc4995423886d320d95936130cb956000916130d157508160011b916000199060031b1c19161790565b90556040519182918261040e565b0390a290565b905084015138610a6c565b90601f1983166130f185600052602060002090565b926000905b828210613157575050926130cb9492600192827fd6a561f68236f1785e9c45009eba5ac6bfb0ae92da53a5dbc4995423886d320d98961061313e575b5050811b019055610480565b85015160001960f88460031b161c191690553880613132565b80600185968294968b015181550195019301906130f6565b600b546001600160401b0391613186838316612ff5565b9280841680936001600160401b03191617600b5582600052602090600a60205260406000209183519182116108dc576131c3826130618554610e54565b602090601f83116001146132195750916130bd827f67a7beac1d9610bc204daae1a6b821d21024a7ab7a5a5984f2083572c713a96195936130cb956000916130d157508160011b916000199060031b1c19161790565b90601f19831661322e85600052602060002090565b926000905b82821061327a575050926130cb9492600192827f67a7beac1d9610bc204daae1a6b821d21024a7ab7a5a5984f2083572c713a96198961061313e575050811b019055610480565b80600185968294968b01518155019501930190613233565b8051156132a0576020015190565b50600090565b9060018060016001600160401b03908160095416925b6132d4575b5050505061041f9161161e91369161098a565b818116838111613334576000908152611496613300602092600884526040809120905192838092610e8e565b8181519101209061331236888a61098a565b80519101201461332b5761332590612ff5565b836132bc565b94505050505090565b506132c1565b9060018060016001600160401b039081600b5416925b613368575b5050505061041f916115f291369161098a565b8181168381116133bf576000908152611496613394602092600a84526040809120905192838092610e8e565b818151910120906133a636888a61098a565b80519101201461332b576133b990612ff5565b83613350565b50613355565b6001600160a01b039190828116908115611d55578260005260008051602061393683398151915260205283604060002054161515806134be575b611d345761343a613412611c3685610db7565b94851691821515958661347e575b5061342a8161268d565b60018154019055611c6e85610db7565b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef600080a461346557565b6040516339e3563760e11b815260006004820152602490fd5b60008681526000805160206139568339815191526020526040902080546001600160a01b03191690556134b09061268d565b805460001901905538613420565b5060016133ff565b90816020910312610353575161041f81610341565b6001600160a01b03918216815291166020820152604081019190915260806060820181905261041f929101906103e9565b3d15613537573d9061351d8261096f565b9161352b6040519384610932565b82523d6000602084013e565b606090565b908160011b918083046002149015171561082c57565b908151811015612dfc570160200190565b60405190606082018281106001600160401b038211176108dc57604052604082526020604036602085013760009160005b8281106135a2575050505090565b6135d682821a600f906135b9828260041c166136d7565b6135cf6135c58661353c565b91891a918a613552565b53166136d7565b906135e08161353c565b6001810180911161082c576135fa600193871a9188613552565b5301613594565b90813b15613687576000805160206138f683398151915280546001600160a01b0319166001600160a01b0384169081179091557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b600080a280511561366c5761366991613819565b50565b50503461367557565b60405163b398979f60e01b8152600490fd5b604051634c9c8ce360e01b81526001600160a01b0383166004820152602490fd5b60ff6000805160206139768339815191525460401c16156136c557565b604051631afcd79f60e31b8152600490fd5b60ff16600a8110156136ff5760300160ff811161082c575b60f81b6001600160f81b03191690565b60610160ff811161082c5760ff60091991160160ff8111156136ef57611bb7565b6001600160a01b0390828216801515908161378b575b50156137425750505050565b1661376057604051637e27328960e01b815260048101839052602490fd5b60405163177e802f60e01b81526001600160a01b039190911660048201526024810191909152604490fd5b8284168114915081156137ce575b81156137a7575b5038613736565b905084600052600080516020613956833981519152602052826040600020541614386137a0565b905060ff613811856119ce8560018060a01b03166000527f80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079305602052604060002090565b541690613799565b60008061041f93602081519101845af461383161350c565b9190613859575080511561384757805190602001fd5b604051630a12f52160e11b8152600490fd5b8151158061388c575b61386a575090565b604051639996b31560e01b81526001600160a01b039091166004820152602490fd5b50803b1561386256fe80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab00793009016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300a66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbcfc545c0151b00b9a0ac4d74abb5522892064539eb246b848b96edccd3302e4be80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab007930280bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079304f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0080bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079301a264697066735822122019f826320ee1e7a30631b489ee6c6574908d7a31af8cf57c41997450e8e1f04964736f6c63430008190033",
    "constructor_args": null,
    "compiler_version": "v0.8.19",
    "optimization_enabled": true,
    "optimization_runs": 200,
    "license_type": "MIT",
    "website_url": "https://vfinance.com.br",
    "tags": [
      "uups",
      "implementation",
      "registry",
      "vehicles"
    ],
    "metadata": {}
  },
  "gas_used": 3256500,
  "timestamp": "2025-08-13T22:47:45Z",
  "tx_hash": "0x6dda0453cc2a80e80936f5dafbaa46a1ae43fa442d1faa7e88dc3be456035e0a"
}